<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8" name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Courier+Prime|Montserrat&display=swap"/><link rel="stylesheet" href="./css/blog.css"/></head><body><div id="layout" class="pure-g"><div><div class="pure-menu pure-menu-horizontal pure-u-1-1 top-header"><a class="pure-menu-heading" href="/">thorstenstark</a><ul class="pure-menu-list"><li class="pure-menu-item"><a class="pure-menu-link" href="/about">About</a></li></ul></div></div><div class="sidebar pure-u-1 pure-u-md-1-4"><div class="header"><div id="layout" class="pure-g"><div class="author__avatar"><img src="https://s.gravatar.com/avatar/30604534421fa73dac944bee03a02aec?s=80"/></div><div class="pure-u-md-1-1 pure-u-3-4"><h1 class="brand-title">Thorsten Stark</h1><h3 class="brand-tagline">An iOS Developers Blog</h3></div></div><div id="layout" class="pure-g"><div class="pure-u-md-1-1"><a href="mailto:mail@thorsten-stark.de"><i class="far fa-envelope-open l-box social-icon"></i><a class="social-media" href="mailto:mail@thorsten-stark.de">Email</a></a></div><div class="pure-u-md-1-1"><a href="https://www.linkedin.com/in/thorsten-stark-857a4436/"><i class="fab fa-linkedin l-box social-icon"></i><a class="social-media" href="https://www.linkedin.com/in/thorsten-stark-857a4436/">LinkedIn</a></a></div><div class="pure-u-md-1-1"><a href="https://github.com/thorstenstark"><i class="fab fa-github l-box social-icon"></i><a class="social-media" href="https://github.com/thorstenstark">thorstenstark</a></a></div><div class="pure-u-md-1-1"><a href="https://twitter.com/Tho_Stark"><i class="fab fa-twitter l-box social-icon"></i><a class="social-media" href="https://twitter.com/Tho_Stark">@Tho_Stark</a></a></div></div></div></div><div class="content pure-u-1 pure-u-md-3-5 pure-u-xl-6-10"><h2 class="post-title"><a href="/posts/Speed-up-dateformatter">Speed up your DateFormatter</a></h2><p class="post-meta">2. Februar 2020</p><div class="post-tags"><a class="post-category post-category-swift" href="/tags/swift">Swift</a><a class="post-category post-category-dateformatter" href="/tags/dateformatter">DateFormatter</a><a class="post-category post-category-date" href="/tags/date">Date</a></div><div class="post-description"><div><h1>Speed up your DateFormatter</h1><p>Maybe you have heard of the slow performance of DateFormatter when it's being initialized. But how slow is it really and what other calls may affect the performance of your app when working with date formats?</p><p>I came across that same question. So I decided to make a little experiment. Fortunately, Xcode has everything we need to measure that kind of metric. In your unit tests there is an option to measure the time of a code block:</p><pre><code><span class="keyword">self</span>.<span class="call">measure</span> {
  <span class="comment">// code block you want to measure</span>
}
</code></pre><p>With this piece of code, it is fairly simple to run tests measuring the time for multiple kinds of operations. To get numbers that better compare I decided to run each target operation 10.000 times. The more samples you have the better the statistical results get.</p><p>One example test case looks like this:</p><pre><code><span class="keyword">func</span> testPerformanceSetFormat() {
    <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()
    <span class="keyword">let</span> dateString = <span class="string">"30.01.2020 19:35"</span>
    <span class="keyword">self</span>.<span class="call">measure</span> {
        <span class="keyword">for _ in</span> (<span class="number">0</span>..&lt;numberOfIterations)  {
            dateFormatter.<span class="property">dateFormat</span> = <span class="string">"dd.MM.yyyy hh:mm"</span>
            <span class="keyword">let</span> _ = dateFormatter.<span class="call">date</span>(from: dateString)
        }
    }
}
</code></pre><p>In total I came up with 12 test cases:</p><ol><li><strong>timeInterval:</strong> <code>Date(timeIntervalSince1970: 597270773.0)</code> as a reference how long it takes to initialize a <code>Date</code> with a <code>TimeInterval</code>. This approach uses no DateFormatter at all.</li><li><strong>DateFormatter (new):</strong> Create a new DateFormatter every time</li><li><strong>DateFormatter (reuse):</strong> Reuse one instance of a DateFormatter without any other changes. All other cases from here will reuse an instance of DateFormatter.</li><li><strong>dateFormat (set), calendar (set), timezone (set):</strong> Set the corresponding value every time to the same value.</li><li><strong>dateFormat (change), calendar (change), timezone (change):</strong> Changes the corresponding value to another value than before.</li><li><strong>calendar (once), timezone (once):</strong> Set the corresponding value only once before the measurement starts.</li><li><strong>cal + timezone (once):</strong> Set both values once before the measurement loop.</li></ol><p>For the cases where a property is actually changed to another value than it had before, I changed the loop a little bit:</p><pre><code><span class="keyword">func</span> testPerformanceAlternatingdTimezone() {
        <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()
        <span class="keyword">let</span> dateString = <span class="string">"30.01.2020 19:35"</span>
        <span class="keyword">let</span> timezone1  = <span class="type">TimeZone</span>(secondsFromGMT: <span class="number">0</span>)
        <span class="keyword">let</span> timezone2  = <span class="type">TimeZone</span>(secondsFromGMT: <span class="number">5</span>)
        <span class="keyword">self</span>.<span class="call">measure</span> {
            <span class="keyword">for _ in</span> (<span class="number">0</span>..&lt;numberOfIterations/<span class="number">2</span>)  {
                dateFormatter.<span class="property">timeZone</span> = timezone1
                <span class="keyword">let</span> _ = dateFormatter.<span class="call">date</span>(from: dateString)
                dateFormatter.<span class="property">timeZone</span> = timezone2
                <span class="keyword">let</span> _ = dateFormatter.<span class="call">date</span>(from: dateString)
            }
        }
    }
</code></pre><p>The number of iterations is cut to half because there are twice as many operations inside the loop.</p><p>Additional to the 10.000 iterations per test case, Xcode runs all tests with a <code>measure</code> block 10 times to calculate a mean value. This is necessary because it isn’t predictable how this single tasks will be scheduled inside the CPU, which results in varying run times. You can see this when you click on the grey diamond near the <code>measure</code> block. In the pop-up, you can see how the 10 runs took different lengths of time.</p><img src="/images/detaformatter_measure.png" alt="Xcode Screenshot" width="200"/><p>I ran the complete test suite 3 times to be able to calculate my own mean values. So remember, the following numbers represent the seconds use for 10.000 operations for the given test case.</p><img src="/images/detaformatter_diagram.png" alt="Measured duration" width="200"/><p>As expected, creating a <code>Date</code> from a <code>TimeInterval</code> is by far the fastest approach. But the surprise is that changing the <code>calender</code> property costs much more time than instantiating a new DateFormatter. And it is nearly 5 times slower than setting it once. Also changing the format seems to be a very expensive task. Whereas changing the timezone causes no significant difference compared to not changing it. It also seems to be a good idea to set <code>calendar</code> and <code>timezone</code> at all instead of going with the default values of DateFormatter.</p><h2>Conclusion</h2><p>Based on these results when working with <code>DateFormatter</code> it seems to be most efficient to have reusable instances for differently configured formatters. This was a date formatter has to be configured only once and can be used again and again with only the minimum amount of computation time. But if you have the chance to use timestamps instead of formatted date strings, you should use it.</p></div></div></div><div class="footer pure-u-1"><div class="pure-u-1">© 2020 Thorsten Stark</div><div class="pure-u-1">Generated using <a href="https://github.com/johnsundell/publish">Publish</a>. Written in Swift</div><div class="pure-u-1"><a href="/feed.rss">RSS feed</a></div></div></div></body></html>