<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Thorsten Stark</title><description>An iOS Developers Blog</description><link>https://thorstenstark.github.io</link><language>en</language><lastBuildDate>Tue, 10 Mar 2020 22:41:03 +0100</lastBuildDate><pubDate>Tue, 10 Mar 2020 22:41:03 +0100</pubDate><ttl>250</ttl><atom:link href="https://thorstenstark.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://thorstenstark.github.io/posts/Migrating-large-git-repository</guid><title>Migrating a large git repository to GitHub</title><description>What is the slowest part of a DateFormatter?</description><link>https://thorstenstark.github.io/posts/Migrating-large-git-repository</link><pubDate>Mon, 3 Feb 2020 22:41:00 +0100</pubDate><content:encoded><![CDATA[<h1>Migrating a large git repository to GitHub</h1><p>We recently wanted to move our repository to GitHub. In theory that should be as simple as clicking the â€žImport Repositoryâ€œ button. So we clicked that button and entered the necessary information for the migration tool. After only 5h hours of migration, the process failed with an â€žError uploading commitsâ€œ. No further information.</p><p>Using the command line to migrate the repository manually showed at least one reason why the upload failed. Our repository contained some files larger than 100 MB. Github has a hard limit when it comes to file sizes. Only files smaller than 100 MB are allowed to be stored in the git repository. Larger files must be stored in git LFS (Large File Storage). Usually, the GitHub migration tool should recognize those files and offer to move them to LFS or remove them from the repository. For unknown reasons, this didn't work for us. If this works for you: lucky you. After a few days struggling with the repository migration and some email exchange with the GitHub support, we figured out a way how to migrate our large repository to Github.</p><p>The short version: <em> Clone your entire repository to your computer </em> Move all large files to LFS <em> Create a local working copy from the modified repository </em> Upload every branch you need to the new remote (Github)</p><p><strong>Prerequisite:</strong> As Git LFS isnâ€˜t part of git itself you have to install it manually on your machine from the <a href="https://git-lfs.github.com">Git LFS</a> page.</p><p>For everyone who doesn't know the concrete steps to do this (like me before) here comes the more detailed version:</p><h2>Step 1 â€“ Clone the complete repository</h2><pre><code>git clone --bare git@hoster.<span class="property">com</span>:username/repository.<span class="property">git</span>
</code></pre><p>This is nearly the same you do with every git repository you clone, but here the parameter <code>--bare</code> is an important difference. A normal <code>git clone</code> will create a so-called working copy of the repository on your computer and checks out the main branch i.e. <code>master</code> or <code>develop</code>. Adding <code>--bare</code> results in a full copy of the repository on your computer. Usually, it also has the extension <code>.git</code> This is the same format as on the remote host. But you can't work in this repository as you can only work in working copies (as the name suggests). <strong>Attention:</strong> After cloning the repository it would be wise to make a backup of this repository in case anything goes wrong especially because we are going to rewrite a great bunch of your git history in a few moments. An easy way to backup is to simply archive the folder called <code>&lt;your-repository-name&gt;.git</code> you just cloned.</p><h2>Step 2 â€“ Move big files to Git LFS</h2><p>Download BFG Repo Cleaner from its website <a href="https://rtyley.github.io/bfg-repo-cleaner/ "here"">here</a>. Next to other features, the one feature we are interested in is its capability to convert files to be stored in Git LFS. And this includes all files in the entire history of your git repository. But be careful, as mentioned earlier this rewrites the history of your repository, making it incompatible with the original version. In this example we want all file with the extensions <code>jpg</code> or <code>mov</code> to be moved to LFS:</p><pre><code>java -jar path/to/bfg-x.<span class="property">y</span>.<span class="property">z</span>.<span class="property">jar</span> --convert-to-git-lfs <span class="string">"{*.jpg,*.mov}"</span> --no-blob-protection path/to/local/repository.<span class="property">git</span>
</code></pre><p>After BFG has done its job we need to clean up a bit. The following command executes some kind of garbage collector to clean up the reflog and remove unused files from the repository.</p><pre><code>cd path/to/local/repository.<span class="property">git</span>
git reflog expire --expire=now --all &amp;&amp; git gc --prune=now --aggressive
</code></pre><p>Next thing to do is to set up Git LFS and the required hooks by calling:</p><pre><code>git lfs install
</code></pre><h2>Step 3 â€“ Upload modified repository</h2><p>The best way now would be to just copy the whole modified repo to its new host. The required command would be this one here:</p><pre><code>git push --mirror git@github.<span class="property">com</span>:username/new-repository.<span class="property">git</span>
</code></pre><p>Unfortunately, this didnâ€˜t work for us so we had to come up with another solution.</p><p>Remember that the repository.git folder is the exact same format as your repository stored on a remote host. This means we can create a working copy from this file:</p><pre><code>git clone path/to/local/repository.<span class="property">git</span>
</code></pre><p>Now we have a checked-out version of our repository and can work on it like in any other cloned repository. We can change files, make commits or change/add the remote. Let's add a new remote pointing to our desired new repository. In this example, we name this new remote just <code>newOrigin</code> as the old remote is still there and is called <code>origin</code> by default. But you can choose any name you like. Just keep the old origin. We will soon see why...</p><pre><code>git remote add newOrigin git@github.<span class="property">com</span>:username/new-repository.<span class="property">git</span>
</code></pre><p>The last step needs some more manual work. We will check out all relevant branches from <code>origin</code> and push/publish them to <code>newOrigin</code> â€“ one by one.</p><p>Congratulations! ðŸŽ‰ You just transferred your too large repository to GitHub!</p><p><strong>Notice:</strong> it may be that some branches were not correctly modified by BFG. This may be caused by special characters in your branch names. You should not upload these branches to <code>newOrigin</code> because the content of this branch is not compatible with the other modified branches anymore. You recognize these branches when they take notably longer to upload than the other branches. Therefore, it helps when the first branch you upload is the master branch. So all other branches rely on commits already pushed with master, except for those branches not modified by BFG.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://thorstenstark.github.io/posts/Speed-up-dateformatter</guid><title>Speed up your DateFormatter</title><description>What is the slowest part of a DateFormatter?</description><link>https://thorstenstark.github.io/posts/Speed-up-dateformatter</link><pubDate>Sun, 2 Feb 2020 22:41:00 +0100</pubDate><content:encoded><![CDATA[<h1>Speed up your DateFormatter</h1><p>Maybe you have heard of the slow performance of DateFormatter when it's being initialized. But how slow is it really and what other calls may affect the performance of your app when working with date formats?</p><p>I came across that same question. So I decided to make a little experiment. Fortunately, Xcode has everything we need to measure that kind of metric. In your unit tests there is an option to measure the time of a code block:</p><pre><code><span class="keyword">self</span>.<span class="call">measure</span> {
  <span class="comment">// code block you want to measure</span>
}
</code></pre><p>With this piece of code, it is fairly simple to run tests measuring the time for multiple kinds of operations. To get numbers that better compare I decided to run each target operation 10.000 times. The more samples you have the better the statistical results get.</p><p>One example test case looks like this:</p><pre><code><span class="keyword">func</span> testPerformanceSetFormat() {
    <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()
    <span class="keyword">let</span> dateString = <span class="string">"30.01.2020 19:35"</span>
    <span class="keyword">self</span>.<span class="call">measure</span> {
        <span class="keyword">for _ in</span> (<span class="number">0</span>..&lt;numberOfIterations)  {
            dateFormatter.<span class="property">dateFormat</span> = <span class="string">"dd.MM.yyyy hh:mm"</span>
            <span class="keyword">let</span> _ = dateFormatter.<span class="call">date</span>(from: dateString)
        }
    }
}
</code></pre><p>In total I came up with 12 test cases:</p><ol><li><strong>timeInterval:</strong> <code>Date(timeIntervalSince1970: 597270773.0)</code> as a reference how long it takes to initialize a <code>Date</code> with a <code>TimeInterval</code>. This approach uses no DateFormatter at all.</li><li><strong>DateFormatter (new):</strong> Create a new DateFormatter every time</li><li><strong>DateFormatter (reuse):</strong> Reuse one instance of a DateFormatter without any other changes. All other cases from here will reuse an instance of DateFormatter.</li><li><strong>dateFormat (set), calendar (set), timezone (set):</strong> Set the corresponding value every time to the same value.</li><li><strong>dateFormat (change), calendar (change), timezone (change):</strong> Changes the corresponding value to another value than before.</li><li><strong>calendar (once), timezone (once):</strong> Set the corresponding value only once before the measurement starts.</li><li><strong>cal + timezone (once):</strong> Set both values once before the measurement loop.</li></ol><p>For the cases where a property is actually changed to another value than it had before, I changed the loop a little bit:</p><pre><code><span class="keyword">func</span> testPerformanceAlternatingdTimezone() {
        <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()
        <span class="keyword">let</span> dateString = <span class="string">"30.01.2020 19:35"</span>
        <span class="keyword">let</span> timezone1  = <span class="type">TimeZone</span>(secondsFromGMT: <span class="number">0</span>)
        <span class="keyword">let</span> timezone2  = <span class="type">TimeZone</span>(secondsFromGMT: <span class="number">5</span>)
        <span class="keyword">self</span>.<span class="call">measure</span> {
            <span class="keyword">for _ in</span> (<span class="number">0</span>..&lt;numberOfIterations/<span class="number">2</span>)  {
                dateFormatter.<span class="property">timeZone</span> = timezone1
                <span class="keyword">let</span> _ = dateFormatter.<span class="call">date</span>(from: dateString)
                dateFormatter.<span class="property">timeZone</span> = timezone2
                <span class="keyword">let</span> _ = dateFormatter.<span class="call">date</span>(from: dateString)
            }
        }
    }
</code></pre><p>The number of iterations is cut to half because there are twice as many operations inside the loop.</p><p>Additional to the 10.000 iterations per test case, Xcode runs all tests with a <code>measure</code> block 10 times to calculate a mean value. This is necessary because it isnâ€™t predictable how this single tasks will be scheduled inside the CPU, which results in varying run times. You can see this when you click on the grey diamond near the <code>measure</code> block. In the pop-up, you can see how the 10 runs took different lengths of time.</p><img src="https://thorstenstark.github.io/images/dateformatter_measure.png" alt="Xcode Screenshot"/><p>I ran the complete test suite 3 times to be able to calculate my own mean values. So remember, the following numbers represent the seconds use for 10.000 operations for the given test case.</p><img src="https://thorstenstark.github.io/images/dateformatter_diagram.png" alt="Measured duration" /><p>As expected, creating a <code>Date</code> from a <code>TimeInterval</code> is by far the fastest approach. But the surprise is that changing the <code>calender</code> property costs much more time than instantiating a new DateFormatter. And it is nearly 5 times slower than setting it once. Also changing the format seems to be a very expensive task. Whereas changing the timezone causes no significant difference compared to not changing it. It also seems to be a good idea to set <code>calendar</code> and <code>timezone</code> at all instead of going with the default values of DateFormatter.</p><h2>Conclusion</h2><p>Based on these results when working with <code>DateFormatter</code> it seems to be most efficient to have reusable instances for differently configured formatters. This was a date formatter has to be configured only once and can be used again and again with only the minimum amount of computation time. But if you have the chance to use timestamps instead of formatted date strings, you should use it.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://thorstenstark.github.io/posts/Better-comparing-dates</guid><title>Better comparing Dates in Swift using Calendar</title><description>What is the slowest part of a DateFormatter?</description><link>https://thorstenstark.github.io/posts/Better-comparing-dates</link><pubDate>Sat, 1 Feb 2020 22:41:00 +0100</pubDate><content:encoded><![CDATA[<h1>Better comparing Dates in Swift using Calendar</h1><p>We often come in a situation where we have to check whether a given <code>Date</code> is on a specific day, hour or week or something like that. In the past we solved this by calculating the date with 0 hours and 0 minutes and then compare it with our given <code>Date</code>. This approach becomes even more complicated and error-prone when you have to work with different timezones.</p><p>Fortunately there is a struct called <code>Calendar</code> which has the pretty little method <code>func compare(_ date1: Date, to date2: Date, toGranularity component: Calendar.Component) -&gt; ComparisonResult</code>. As its name suggest, it compares two <code>Date</code> objects to a given granularity</p><pre><code><span class="keyword">var</span> calender = <span class="type">Calendar</span>.<span class="property">current</span>
calender.<span class="property">timeZone</span> = <span class="type">TimeZone</span>.<span class="property">current</span>
<span class="keyword">let</span> result = calender.<span class="call">compare</span>(date, to: now, toGranularity: .<span class="dotAccess">day</span>)
<span class="keyword">let</span> isSameDay = result == .<span class="dotAccess">orderedSame</span>
</code></pre><p>Instead of <code>.day </code> also every other <code>Calendar.Component</code> is possible. Here is a list of some (but not all) <code>Calendar.Component</code> :</p><ul><li>.minute</li><li>.second</li><li>.month</li><li>.weekOfMonth</li><li>.weekday</li></ul>]]></content:encoded></item></channel></rss>